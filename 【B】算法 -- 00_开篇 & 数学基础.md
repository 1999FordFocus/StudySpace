## 【B】算法：开篇 & 数学基础



### 算法评价标准

#### 时间复杂度分析

加法法则：

​	多个循环，并列关系，各复杂度相加关系，但只关注复杂度最大时间复杂度



乘法法则：

​	嵌套两层或多层循环或递归，各层时间复杂度相乘



对于数据规模n ：

- ​	被完整循环c*n次 ： O（n^1）


- ​	两层循环，n不在循环内动态修改 ： O（n^2）


- ​	一次递归调用或循环中n被折半 :    O(logn) ，即求递归深度，递归多少次n被递归到底。

  ```
   i=1;
   while (i <= n)  {
     i = i * 2;
   }
  ```

  ```
   i=1;
   while (i <= n)  {
     i = i * 3;
   }
  ```

  

​		对数之间是可以互相转换的，log3n 就等于 log32 * log2n，所以 O(log3n) = O(C * log2n)； 统一都计为O（logN）

- ​	多次递归调用，需要画出递归树




对于两个变量决定，且有各自数据规模m，n的算法：

```
int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
```



加法法则要改成O（M+N），乘法法则依旧有效，O（M*N）





#### 空间复杂度分析

空间复杂度：开辟的存储空间与数据规模n之间的增长关系。



对于数据规模n：

​	多开一个辅助的数组 ： O(n)

​	多开一个辅助的二维数组：O(n^2)

​	多开常数空间：O(1)





#### 最好、最坏时间复杂度

来个稍微复杂的例子：

```
// n表示数组array的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
```

最坏的情况，x不存在于数组中，这样就得遍历一遍数组，才知道结果。O(n)

最好的情况，第一个位置就是x，程序结束，O(1)






#### 稳定性

**排序前相等元素，排序后其相对次序不发生改变**。这个性质对于复杂对象排序来讲尤为重要。对于单一元素（比如数字）排序，毫无意义。





#### 常见数据结构复杂度一览

![image-20210114114027618](E:\personal\study\StudySpace\images\image-20210114114027618.png)





### 数学基础补足







### 参考资源

- 程序员数学基础课

  https://time.geekbang.org/column/article/79048

