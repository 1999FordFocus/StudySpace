## 【B】00_字符串问题



### 字符串问题集合

- **KMP算法**

- 求两个字符串最长连续公共序列，查找最长子串
- 给定一个字符串（只有小写字母）和m步操作，每一步操作可以把相邻
- 两个字符交换位置，问最多执行m步操作后，字符串中最长连续相同字符的长度是多少
- **输入一个字符串(不含****和.)、正则(字母、****和.任意组合)，判断字符串是否合法**

- **给定一个只包括 ‘(’，’)'的字符串，判断字符串是否有效。注：空字符串属于有效字符串**

示例 1:输入: "(())"输出: true   实例 2： 输入: "())("输出: false 12345678

https://www.toutiao.com/a6772138712785486350/





### 模式匹配算法



#### 暴力匹配

基本思想是：

1. 从主串的第一个字符起与子串的第一个字符进行比较，若相等，则继续逐对字符进行后续的比较；

2. 若不相等，则从主串第二个字符起与子串的第一个字符重新比较，以此类推，
   直到子串中每个字符依次和主串中的一个连续的字符序列相等为止，此时称为匹配成功。

3. 如果不能在主串中找到与子串相同的字符序列，则匹配失败。

   

```java
public static int bruteForce(String s,String p) {
	int index = -1; //成功匹配的位置，匹配不到返回-1
	int sLength = s.length();
	int pLength = p.length();
	if(sLength < pLength) {
		 System.out.println("Error.The main string is greater than the sub string length.");
		return -1;
	}
	int i = 0;//当前遍历主串的下标
	int j = 0;//当前遍历字串的下标
	//暴力遍历串
	while(i < sLength && j < pLength)  {
		if(s.charAt(i) == p.charAt(j)) {
			//字符相等，指针后移
			i++;
			j++;
		}else {
			//主串回到上次匹配的字符的下一个字符，子串从0开始
			i = i - j + 1;//主串需要归还i向前走的j步，然后加1
			j = 0; //子串无须关注向前走了多少步，直接归零
		}
	}
	
	if(j == pLength) { //匹配成功
		index = i - j;
		System.out.println("Successful match,index is:" + index);
	} else {// 匹配失败
        System.out.println("Match failed.");
    }
	return index;
}
```






#### KMP算法

暴力匹配算法中，每次失配，主串的指针都要回溯，性能低下。	

KMP的核心思想就是主串不回溯，模式串尽量多地往右移动。

  

##### 前缀和后缀

”Harry”的前缀包括{”H”, ”Ha”, ”Har”, ”Harr”}

”Potter”的后缀包括{”otter”, ”tter”, ”ter”, ”er”, ”r”}



#####  PMT 表 与  next数组

实现KMP算法的核心在于PMT （部分匹配表，Partial Match Table）这个数据结构。对于字符串“abababca” ，它的PMT如下表示：

| char  | a    | b    | a    | b    | a    | b    | c    | a    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| index | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| value | 0    | 0    | 1    | 2    | 3    | 4    | 0    | 1    |

**PMT 中记录的是index位置的元素之前的子串[0,index），即[0,index - 1 ] 区间内构成的子串，前缀集合与后缀集合的交集中最长元素的长度，即前缀与后缀的 “相等” 程度。这样，一旦在该位置发生失配（该位置之前都是匹配的），不需要从子串（模式）串头再重新匹配，而是从前缀中跳过 “相等” 的那部分元素的长度，接着比较。**



为了编程的方便， 我们不直接使用PMT数组，而是将PMT数组向后偏移一位。我们把新得到的这个数组称为next数组。在把PMT进行向右偏移时，第0位的值，我们将其设成了-1，这只是为了编程的方便，并没有其他的意义。



next数组：

| char  | a    | b    | a    | b    | a    | b    | c    | a    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| index | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| value | 0    | 0    | 1    | 2    | 3    | 4    | 0    | 1    |
| next  | -1   | 0    | 0    | 1    | 2    | 3    | 4    | 0    |





```java

	//第一步：构造next表
	private static int[] buildNext(String p) {
		int[] N = new int[p.length()];
		int m = p.length();
		int j = 0;
		int t = N[0] = -1; //为编程方便，将PMT改造一下，0位置赋值-1，形成next表
		while(j < m - 1) {
			if(t < 0 || p.charAt(j) == p.charAt(t)) {
				j++;
				t++;
				N[j] = t;
			}else {
				t = N[t];
			}
		}
		return N;
	}
	
	//第二步：利用next表尽量多地往右移动
	public static void kmp(String s ,String p) {
		long beginTime = System.currentTimeMillis();
		int[] next = buildNext(p);
		int index = -1;//返回成功匹配的位置，没查找到返回-1
		int sLength = s.length();
		int pLength = p.length();
		if(sLength < pLength) {
			return;
		}
		int i = 0;
		int j = 0;
		while(i < sLength && j <pLength) {
            // j==-1 处理第0个位置的元素失配的情况
			if(j == -1 || s.charAt(i) == p.charAt(j)) {
				i++;
				j++;
			}else {
          		// 主串 i 不变
				j = next[j];//表示在j位置失配时，查找一下next表中记录的，前后缀相交个数，并将（个数 + 1）作为下次匹配时的起始下标。
			}
		}
		if(j >= pLength) {
			 index = i -j;
			 System.out.println("KMP Successful match,index is:" + index);
		}else {
			 System.out.println("Match failed.");
		}
		long endTime = System.currentTimeMillis();
		System.out.println("KMP cost time = "+(endTime - beginTime));
	}

```







































