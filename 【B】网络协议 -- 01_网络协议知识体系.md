## 【B】网络协议 -- 第一部分: 网络协议知识体系

> 昔日戏言身后意，今朝都到眼前来。衣裳已施行看尽，针线犹存未忍开。
>
> 尚想旧情怜婢仆，也曾因梦送钱财。诚知此恨人人有，贫贱夫妻百事哀。
>
> -- 《遣悲怀》唐·元稹



### 输出倒逼输入

- 如何保证数据的有效性？

- 如何保证对方收到了消息？

- 讲讲拥塞避免算法 -- TCP4种拥塞控制策略

- tsl的握手和具体的非对称加密算法。非对称名称。常用的对称加密算法，有什么同

- 网络劫持的类型原理

  







### 基础知识

**协议三要素 ：**

- 语法 
- 语义
- 顺序



#### 一次网络通信的大致流程

​	要访问一个URL，**应用层**首先要通过地址薄协议DNS或者HTTPDNS，最终得到目标 ip 地址。得到地址后，根据HTTP或者HTTPS协议封装请求包。通过Socket编程将包从应用层传到传输层。**传输层**（添加TCP头）有两种协议TCP、UDP。TCP能够保证包到达目的地，如果不能到达，就会重新发送。接下来包交给**网络层**，**网络层**（添加ip头）协议是 ip 协议。 操作系统启动时会被DHCP协议配置IP地址以及默认的网关的IP地址 192.168.1.1，客户端通过本地局域网广播询问网关mac地址，数据链路层 ARP（地址解析协议）提供ip地址解析成MAC地址服务。ip包从客户端发送MAC层（数据链路层第一子层，添加MAC头），继而通过数据链路层网关的MAC地址，再将包发到网关。网关根据路由表进行跳转，网关间通过路由协议OSPF和BGP沟通。

​	最后一个网关知道这个网络包就是要去这个局域网的，于是拿着目标IP通过ARP协议大喊一声这是谁？ 目标服务器就会给网关回复一个MAC地址。 然后网络包在最后那个网关修改目标的MAC地址，通过这个MAC地址，网络包找到了目标服务器。目标服务器发现MAC地址对上了，取下MAC头来，发送给操作系统网络层，网络层取下IP头，然后交给传输层即TCP层。在这一层里，对于收到的每个包，都会有一个回复，报个平安说包收到了。TCP 头中有目标端口号，可以找到服务端正在监听这个端口号的进程，于是服务端就接收到了HTTP请求包的内容。

#### ![img](.\images\5985d6d430e1b1d3f165bf0f916ed954.jpg)

自己写程序简单实现网络通信模型：

![img](.\images\5c00f6e610f533d17fb4ad7decacc776.jpg)









#### 网络分层的意义

​		只要是在网络上跑的包，都是完整的。可以有下层没上层，绝不可能有上层没下层。对于TCP协议来说，三次握手也好，重试也好，只要想发出去包，就要有IP层和MAC层，不然是发不出去的。

​		Linux 默认的逻辑是，如果这是一个跨网段的调用，它便不会直接将包发送到网络上，而是企图将包发送到网关。





#### IP地址的分配 -- 动态主机配置协议（DHCP）

​	新来的客户机只知道自己mac地址而已，它想要申请一个ip地址，所以使用 0.0.0.0为源ip地址、255.255.255.255为目标ip地址进行广播，这个广播包封装了UDP，UDP封装了BOOTP。

​	![image-20201022141422500](.\images\image-20201022141422500.png)

DHCP server 接收到之后，以客户机mac地址为唯一识别符 ， 通过广播下发DHCP Offer: 

![image-20201022141126092](.\images\image-20201022141126092.png)



客户端从多个Offer中选一个，并发送DHCP request广播数据包表示接收租约。

DHCP Servier 会广播返回给客户机DHCP ACK消息包，确认其加入并将ip地址合法租用信息和配置信息一并放入。







### 网络模型 -- 第二层（数据链路层）到第三层（网络层）



#### ARP 协议

​	在一个局域网里边，知道了ip地址不知道mac地址怎么办呢？ 靠“吼” 。广而告之，发送一个广播包，谁是这个 IP 谁来回答。

![image-20201022143855920](.\images\image-20201022143855920.png)

​	广播报文结构：

![image-20201022144051361](.\images\image-20201022144051361.png)

​	避免每次都用 ARP 请求，机器本地也会进行 ARP 缓存。当然机器会不断地上线下线，IP 也可能会变，所以 ARP 的 MAC 地址缓存过一段时间就会过期。



#### MAC头和IP头的细节

![img](.\images\825e54560a6de08a32e4cab4e0f59f65.jpg)



MAC 头里协议类型用来说明里面是IP 协议。

IP 头里边的版本号，目前主流还是IPV4。TTL是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃。8位协议标识，标识下一层协议是TCP还是UDP。



要访问一个ip地址的时候，先判断是否在同一个网段（用到 CIDR和子网掩码进行“与”操作，判断网络号是否相同）。

**如果是同一网段**，那就直接将源地址和目标地址放入ip头，然后通过ARP获得MAC地址，将源MAC和目的MAC放入MAC头中，发出去就可以了。



​	路由器不等于网关。路由器有5个网口或者网卡，分别连着五个局域网，每个网口的IP地址都和局域网的IP相同网段，它是把守这个局域网的网关。任何一个想要发往其他局域网的包，到达网关后拿下MAC头和IP头，根据自己的路由算法，选择另一个网关，加上IP头和MAC头，然后扔出去。



​	MAC地址是一个局域网内才有效的地址。离开本局域网，就要过网关，MAC头要变，而IP地址如果不改变则称为转发网关，比作“欧洲十国游，不用换护照”；改变IP地址的称为**NAT网关（Network Address Translation）**，比作“玄奘西行，要换通关文牒”



#### 静态路由

​	路由器根据路由表来正确转发流量，一张路由表中包含多条路由规则，其中至少包含三项信息：

- 目的网络：这个包想去哪？
- 出口设备：将包从哪个口扔出去
- 下一条网关：下一个路由器的地址



>  根据 IP 地址静态配置路由规则

```makefile
例如，我们设置 ip route add 10.176.48.0/20 via 10.173.32.1 dev eth0，就说明要去 10.176.48.0/20 这个目标网络，要从 eth0 端口出去，经过 10.173.32.1。
```

​	

#### 动态路由协议

​	动态路由路由器可以根据路由协议算法生成动态路由表，随网络运行状况的变化而变化。路由算法即是求**最短路径**常用的有两种方法，一种是 Bellman-Ford 算法，一种是 Dijkstra 算法。



1. **基于链路状态路由算法的OSPF**

   链路状态路由（link state routing），基于Dijkstra算法实现。思路是：路由器启动的时候向邻居say hello，计算和邻居的距离，然后将自己和邻居之间得链路状态包广播出去，发送到整个网络得每个路由器，因而每个路由器都能在本地构建一个完整得图，然后针对这个图使用Dijkstra算法，找到两点之间最短路径。

   

   相比距离矢量路由更新时发送整个路由表，链路状态路由协议，只广播更新得或改变得网络拓扑，一旦路由器挂了，可使得坏消息迅速收敛。

   

   **OSPF （Open Shortest Path First ， 开放式最短路径优先）**，被称为**内部网关协议（Interior Gateway Protocol ，简称IGP**）。在一个组织内部，最短路径往往最优，有时候OSPF可以发现多个最短路径，可以在多个路径中进行**负载均衡**，这常常称为**等价路由**。

   

   

2. **基于距离矢量路由算法的BGP协议**

   距离矢量路由（Distance vector routing），基于 *Bellman-Ford* 算法实现。思路是：每个路由器都保存一个路由表，每过几秒，每个路由器都将自己所知的到达所有路由器的距离告知邻居，每个路由器也都从邻居那里得到相似的信息。根据新收集的信息，计算和其他路由器的距离。

   ![image-20201028144234349](.\images\image-20201028144234349.png)

   问题1：“坏消息” 同步得慢

   ​	如果目的路由器挂掉了，那么源路由器仍然将尝试各种路径访问，直到试过所有路径。

   

   问题2：每次发送都要发送整个全局路由表。

   

   **外网路由协议（Border Gateway Protocol，简称BGP）**。BGP协议使用的是**路径矢量路由协议(path-vector protocol)** 。它是距离矢量路由协议的升级版。在网络世界，一个个国家称为自治系统AS（Autonomous System），都有边界路由器，通过它和外面得世界建立联系，边界路由器间使用eBGP广播路由，边界路由器再通过运行iBGP，将学习到的路由导入到内部网络。

   

   

   

   

### 网络模型 -- 传输层

> TCP 与 UDP的区别?

1. TCP提供可靠交付。先建立连接，再传输数据，保证无差错、不丢失、不重复并且按序到达。
2. TCP面向字节流，UDP基于数据报，一个个发一个个收。
3. TCP有拥塞控制。





#### UDP 协议

> UDP包头

![image-20201028161716334](.\images\image-20201028161716334.png)

​	当UDP包到达目标机器后，发现MAC地址匹配，于是取下MAC头，将剩下的包传给IP层，将IP头取下，IP头有8位协议位，标识TCP协议还是UDP协议，我们知道了UDP头格式，解析数据，并能交给应用层，无论应用使用TCP还是UDP传数据，都要监听一个端口，正是这个端口用来区分应用程序。

![img](https://image.fundebug.com/2019-03-21-02.gif)

**应用场景**

	1. 需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用。
	2. 不需要一对一沟通，建立连接，而是可以广播的应用。
	3. 需要处理速度快、延迟低，可以容忍少数丢包，但是要求即便网络拥塞，也不主动降低速度

​	DHCP、VXLAN、QUIC等





#### TCP协议

TCP可靠性主要体现在五个方面：

1. 连接维护

2. 顺序问题

3. 丢包问题

4. 流量控制

5. 拥塞控制

   

> TCP头格式

![image-20201028162436982](.\images\image-20201028162436982.png)





TCP是面向连接的，因而双方要维护连接的状态。通过规定一些状态位来实现，例如SYN是发起一个连接，ACK是回复，RST是重新连接，FIN是结束连接。这些带状态位的包的发送，会引起双方的状态变更。

给包编号seq，以解决乱序的问题。

收到后确认序号，如果没收到就该重新发送，解决丢包问题。



##### 连接维护--三次握手与四次分手

​	一条TCP连接是由四元组标识的，分别是 


$$
源IP、源端口、目的IP、目的端口
$$


一旦一个元素发生变化，就需要断开重连。比如手机信号不稳定或者WIFI和移动网络切换时，导致重连造成一定时延。



**TCP的三次握手**

三次握手的作用是 *双方都能明确自己和对方的收、发能力是正常的*。

主要内容是：1. 双方建立连接 2.沟通初始TCP包的序列号

> **三次握手具体过程与状态机变化：**

![image-20201028164625521](.\images\image-20201028164625521.png)



TCP是全双工通信。通信双方都要完成一次 "发送 - 接收“,方可确定连接建立。一开始，客户端与服务端都处于CLOSED状态。先是服务端主动监听某个端口，处于LISTEN状态。然后客户端主动发起连接SYN，之后处于SYN-SENT状态。服务端收到连接，返回SYN，并且ACK客户端的SYN，之后处于SYN-RCVD状态。客户端收到服务端发送的SYN和ACK之后，发送ACK的ACK，之后处于ESTABLISHED状态，因为它一发一收成功了。服务端收到ACK的ACK之后，处于ESTABLISHED状态，因为它也一发一收了。



每个连接都要有不同的序号，生成序号的机制就是ISN （ initialization sequence number ），序号每4微秒自动加1。避免出现第二次握手丢失的包，绕路又回来了，干扰重试过程，也避免浪费服务端资源。





**TCP四次挥手状态时序图**

![image-20201028192853041](.\images\image-20201028192853041.png)****



1. 客户端发送FIN段，包含seq=p，表示” 不玩了 “ 。之后进入FIN_WAIT_1状态，此时不能再发出数据但是可以接收数据
2. 服务端返回ACK ，并且ack = p+1，表示” 知道了 “ 。之后服务端进入CLOSED_WAIT状态，此时服务端依然可以发
3. 客户端收到后，进入FIN_WAIT_2状态。
4. 服务端主动发送FIN段，表示” 我也不玩了 “。此后不再发送数据。
5. 客户端收到后，返回ACK，表示 ” 确认已关闭 “。进入TIME_WAIT状态，开始等待2MSL (最大报文生存时间，Maximum Segment Lifetime。协议规定2分钟，实际一般30秒）， 此为等待未收到的数据。



- 为什么这样设计？

  对于关闭连接来说，如果两方谁采取直接“跑路 ”式策略。客户端如果只是通知了一次FIN 就“ 跑路 ”的话，服务端不知道如何处理，没发完的数据还要不要了 ? 而如果服务端收到后直接 “ 跑路”  的话，客户端就不知道服务端是怎么一回事， 是有事要处理，还是等一会儿会发送结束。

- 为什么握手是3次，分手是4次？

  客户端发送FIN表示关闭连接不再发数据后，服务端要立即回复 ACK表示 ” 关闭连接的请求收到了”  ，否则由于TCP协议特性，客户端可能认为丢包了，会重新发送。但这时候只是进入了半关闭状态，服务端是“被通知关闭”的一方，它要等待数据发送完，才能发送自己的FIN 告知客户端连接已关闭，不再发数据。所以相比握手，多出来一步。握手的时候，是服务端在LISTEN状态下，万事俱备静静等待连接请求。



##### 顺序问题、丢包问题

​	顺序问题、丢包问题、流量控制都是通过**滑动窗口** 即rwnd来解决的。

发送方和接收方各自保持一个数据结构来缓存发送和接收的包。接收方在TCP头里报给发送方一个窗口大小，称为Advertised Window。

发送方拿着这“窗口”，在自己的发送消息缓存“队列”里滑动，超出窗口的部分就不能发送了：

![img](E:\personal\study\StudySpace\images\16dcd6fb8105a1caa75887b5ffa0bd7b.jpg)



对于接收方

![img](.\images\f7b1d3bc6b6d8e55f0951e82294c8ba4.jpg)

LastByteRead 表示已接收，应用已读取的位置，即上次读取到的位置。

NextByteExpected 表示下次确认接收的位置。

NextByteExpected 与 LastByteRead 之间表示已接收但应用层还未读取的量，姑且定义为A。

那么Advertised Window大小就应该是 ， MaxRevBuffer 减去A。



真实环境里，如果出现丢包，顺序也就乱了。解决方案一种是**超时重试机制** ：

​	对每一个发送了但是没有ACK的包，设定一个计时器，然后重新发送，这个超时时间通过采样 RTT（Round-trip time)  然后加权平均计算出来。再次超时，超时时间间隔加倍。

​	这个方案问题是超时周期太长，优化方案是**快速重传机制**。接收方收到一个序号大于所期望的报文段时，连续发送冗余的所期望的报文段的ACK发送方收到三个冗余的ACK后，不等超时，马上重发。

​	另一种方案是**SACK（Selective Acknowledgement）**。在TCP头里加一个SACK的东西，将缓存的地图发给发送方，例如可以发送ACK6、SACK8、SACK9，发送方一下子可以看出来7丢了。





##### 流量控制

​	如果接收方处理太慢，可以修改窗口大小，设置设置为0，则发送方将暂停发送。为防止“低能窗口综合症” 即接收方空出来一个字节就赶快告诉发送方，发送方就发送一个字节将其填满的情况，当窗口太小的时候，不更新窗口，直到达到一定大小。发送方定时发送窗口探测数据包，看是否有机会调整窗口大小。





##### 拥塞控制

​	滑动窗口主要怕发送方把接收方的缓存塞满，**拥塞窗口** 即cwnd 是怕把网络塞满。水管有粗细，网络有带宽，理想状态下，水管里面的水量 = 水管粗细 x 水管长度。对于网络传输，通道的容量 = 带宽 x 往返延迟。

​	传统拥塞控制四个算法为：*慢启动，拥塞避免，快重传和快恢复*。





​	谷歌推出新的拥塞控制算法 ：**TCP BBR 拥塞算法**企图找到一个平衡点，通过不断地加快发送速度，将管道填满，但是不要填满中间设备地缓存，在这个平衡点可以很好地达到高带宽和低时延。

![img](.\images\a2b3a5df5eca52e302b75824e4bbbd4c.jpg)



























#### 套接字Socket

##### **基于TCP协议的Socket程序函数调用过程**

![img](.\images\77d5eeb659d5347874bda5e8f711f692.jpg)

**Socket连接的创建**

两端创建Socket；

TCP的服务端先监听一个端口 -- 一般是调bind函数，将一个 IP 和端口赋予这个Socket；

**TCP**的服务端再调listen 函数，进入TCP状态机里的 LISTEN状态；

客户端设定要连接的IP和端口号，调用connect函数发起连接 -- 三次握手。

> 在一次三次握手建立连接的过程中，服务端先后进入等待 SYN_RCVD 和 完成建立 ESTABLISHED两个状态，系统内核中也会为每个Socket 根据客户端发来的连接的状态维护这样两个队列。

一旦三次握手成功连接建立，服务端的accept会从已建立连接的队列中取出连接进行处理，并给客户端返回另一个Socket，并通过这个Socket进行数据读写。***服务端用来监听的Socket和真正用来传数据的Socket是两个，一个叫监听Socket一个叫已连接Socket。***



**Socket的本质**

Socket在Linux中是以文件形式存在的。每个进程都有一个数据结构task_struct，指向一个文件描述符数组。文件描述符数组本身是个指针数组，指向内核中打开的文件的列表。Linux中每个打开的文件对应一个inode ， Socket对应的inode在内存中，在这个inode中，指向了Socket在内核中的Socket结构。在这个结构里主要是两个队列，一个**是发送队列**，一个是**接收队列**。

> 文件描述符 ：系统为高效管理被打开的文件所创建的索引，其是一个非负整数，用于指代被打开的文件。

![img](.\images\602d09290bd4f9e0183f530e9653348c.jpg)







##### **基于UDP协议Socket程序函数调用过程**

因为没有维护连接状态的，只要有一个Socket就可以与多个客户端通信。每次通信的时候都调用sendto和recvfrom ，都可以传入IP地址和端口.

![img](.\images\778687d1a02ffc0c24078c33be2ac1ef.jpg)





##### epoll -- 最大并发TCP连接支持

epoll 函数在内核中通过注册callback的方式，监听多个Socket文件变化。

![img](.\images\cff688ede147809da4d65fe4152ffb19.jpg)

epoll_create创建一个epoll对象，也是一个文件，对应着一个文件描述符，同样对应打开文件列表中的一项，其中有一个红黑树，在红黑树里保存着这个epoll要监听的所有Socket。当epoll_ctl添加一个Socket的时候，其实是加入这个红黑树，同时红黑树里边的节点指向一个结构，将这个结构挂在被监听的Socket的事件列表中。当一个Socket来了一个事件的时候，可以从这个列表中得到epoll对象，并调用call back。













### 网络模型 -- 应用层

#### HTTP 协议

##### HTTP 1.1

###### HTTP请求

1. **请求的准备**

   请求地址发给DNS服务器，将域名解析成为IP地址。

   建立TCP连接。HTTP 1.1 默认开启Keep-Alive ，这样建立的TCP连接就可以再多次请求中复用。

2. **HTTP请求的构建 -- 请求行、首部字段、实体**

   **第一部分 ：请求行** 

   包括 请求方法 、URL、HTTP版本

   请求方法：GET、POST、PUT、DELETE...

   GET方法将URL和参数拼接，对于apache服务器限制8192字符、ngnix服务器长度限制是4k，超过长度将被截断。

   **第二部分：请求首部字段**

   | Accept-Charset    | 客户端接受的字符集                                           |
   | ----------------- | ------------------------------------------------------------ |
   | Content-Type      | 正文的格式，常见的：application/x-www-form-urlencoded、application/json、text/xml、multipart/form-data。（used with POST、PUT请求） |
   | Cache-control     | 作为请求头时控制缓存的字段。                                                                         *max-age 客户端给定一个时间，告诉服务器在这个时间内资源是”fresh“的，客户端可以接收在这个时间内的缓存。与Expires字段同时存在时，HTTP1.1 优先处理max-age而忽略Expires，HTTP1.0协议则相反。                                                                                  * no-store:不缓存请求或响应的任何内容                                                                                             *no-cache :     不是”不缓存“，而是不缓存过期的资源，强制向资源服务器再次验证有效期 |
   | If-Modified-Since | 规定一个时间点，如果服务端资源在这个时间点后更新了，客户端才更新，否则服务端返回 “ 304 Not Modified" 客户端就不用下载了。 |
   | If-None-Match     | 规定一个资源tag，如果ETag命中则服务端返回 “ 304 Not Modified" 客户端就不用下载了，否则表示资源不存在缓存，服务端将处理请求并返回资源。 |
   | Range             | 请求部分实体，即一定范围内的字节。用作文件下载、断点续传     |

   [https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Field_names]: 	"参见wik"

   

   如图可见Nginx如何处理HTTP协议，对于静态资源有Vanish缓存层，如果Cache-Control 字段max-age指定为0，那么缓存层通常需要将请求转发给应用集群  

   ![img](.\images\c81af7a52305f7de27e32e34a02d0eac.jpg)

   

   

   

3. **HTTP请求的发送**

   - HTTP请求报文拼凑好，通过Socket 以stream 二进制流形式传到TCP层。

   - TCP层把二进制流变成一个个报文段发给服务器。TCP层发送每一个报文的时候，都需要加上源地址和目标地址，将其放入IP头里面，交给IP层。

   - IP层查看目标地址和自己是否在同一个局域网。如果是，则通过ARP协议来请求这个目标地址对应的MAC地址，然后将源MAC和目标MAC放入MAC头，发出去即可。如果不在同一个局域网，就需要发送到网关，还需要发送ARP协议来获取网关的MAC地址，然后将源MAC和网关的MAC放入，发送出去。
   - 到达最后一跳的路由器，发现目标地址就在自己的某一个出口的局域网上，于是在这个局域网上发送ARP，获得这个目标地址的MAC地址，将包发送过去。
   - 目标机器发现MAC地址符合，就根据IP头中协议项，知道上一层是TCP协议，于是解析TCP头并返回ACK。
   - TCP头里有端口号，在监听这个端口号的HTTP服务器于是可以接收到HTTP请求。

   

   

4. **HTTP返回的构建** -- 状态行、首部、实体

   **第一部分 ：状态行** 

|      | 类别                                   | 状态码 | 描述                                                         |
| ---- | -------------------------------------- | ------ | ------------------------------------------------------------ |
| 1XX  | 信息性状态码。表示接收的请求正在处理。 |        |                                                              |
| 2XX  | 成功状态码。请求正常处理完毕。         | 206    | 表示客户端进行了范围请求。服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。 |
| 3XX  | 重定向状态码。                         | 301    | 永久性重定向。                                               |
|      |                                        | 302    | 临时性重定向。希望本次使用新的URI访问。                      |
|      |                                        | 303    | See Other。明确表示应使用GET方法重新定向获取请求的资源。     |
|      |                                        | 304    | Not Modified。304本身跟重定向没什么关系。它表示采用GET方法请求报文中包含了附带条件，比如：If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任意一首部，但是未满足条件时返回。 |
| 4XX  | 客户端错误状态码。服务端               | 400    | Bad Request。请求报文存在语法错误。                          |
|      |                                        | 401    | Unauthorized。需要通过HTTP认证（BASIC认证、DIGEST认证），若之前已经进行过一次请求则表示用户认证失败。 |
|      |                                        | 403    | Forbidden。拒绝访问                                          |
|      |                                        | 404    | Not Found。服务器上无法找到请求的资源，也可以用于服务端拒绝请求且不想说明理由时。 |
| 5XX  | 服务器错误状态码。服务器处理请求出错。 | 500    | 服务器在执行请求时发生了错误。也有可能是应用存在的bug或某些临时的故障。 |
|      |                                        | 503    | Service Unavailable。表示超负载或临时维护。与Retry-After配合，告知客户端应该在多长时间后再发请求 |



**第二部分：响应的首部字段**



| Retry-After  | 服务端返回503，告知客户端应该在多长时间后再发请求 |
| ------------ | ------------------------------------------------- |
| Content-Type | text/html，application/json,,,                    |
|              |                                                   |
|              |                                                   |





###### **HTTP 缓存机制**

主要利用Cache-control和ETag两个字段，通过客户端服务端配合来实现缓存机制。

https://en.wikipedia.org/wiki/Web_cache#Cache-control

https://en.wikipedia.org/wiki/HTTP_ETag



okHttp中就是使用了Http的缓存机制，而不是像Volley等框架那样自己写一套缓存策略。



Cache-Control主要包含几个值：

private ： 只有客户端可以缓存；

public ： 客户端和代理服务端都可以缓存；

max-age：缓存的过期时间；

no-cache：需要对比缓存来验证缓存数据；

no-store ：不进行缓存；



Etag 即实体标记，是与服务端特定资源关联的确定值。资源更新后ETag也会随之更新。当客户端第一次请求时，服务端会下发当前请求资源的标识码ETag，下次请求时，客户端通过header里的If-None-Match将ETag带上，服务端对比资源ETag，如果一样，表示没有更新，返回304.







###### **使用Cookie的状态管理**

HTTP是无状态协议，优点是减少服务器的CPU及内存资源消耗。Cookie技术是通过在请求和相应报文中写入Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往服务端发起请求时，客户端自动在请求报文中加入Cookie。服务端检查后便可得到之前的状态信息。大小一般不超过4k



Session是服务端中用来保存一次会话中常用的变量信息的，一般失效时间很短，关闭客户端或者Session超时就会失效。



SessionID是Cookie和session的一道桥梁。





###### **Http1.1的不足：**

- ​	Http 1.1 在应用层以纯文本形式通信

- ​	Http 1.1 每次通信要带完整的HTTP 头

- ​	HTTP和TCP队头阻塞问题

​		TCP数据包是有序传输，中间一个数据包丢失，会等待该数据包重传，造成后面的数据包的阻塞。一个数据包影响了一堆数据包，它不来大家都走不了。可能存在于HTTP层和TCP层。

​		HTTP1.1中在持久链接上使用管道化特性，要求服务端必须按照请求发送的顺序返回响应，那如果一个响应返回延迟了，那么其后续的响应都会被延迟，直到队头的响应送达，导致http队头阻塞。



##### HTTP 2.0 的改变

- 头部压缩

  HTTP2.0会对HTTP的头进行一定的压缩，将原来每次都要携带的大量的key-value在两端建立一个索引表，队相同的头只发送索引表中的索引。



- 二进制分帧协议
- 将一个TCP连接切分成多个流，每个流都有自己的ID，将传输信息分割为更小的消息和帧，Header帧会开启一个新的流、Data帧用来传输正文实体，多个Data帧属于同一个流，并对它们采用二进制格式编码。乱序发送到一个TCP连接中。解决了HTTP1.1中的队首阻塞问题，而且减少了TCP连接数。



- 多路复用

  多路复用机制解决了HTTP层的队头阻塞问题（TCP层队头阻塞问题依然存在）。

  

- 流量控制

  





**HTTP2.0 的不足**

HTTP2.0是基于TCP协议的，所以它的不足本质还是TCP 的问题：

- 建立连接时间长(本质上是TCP的问题)

  TCP三次握手加上HTTPS中TLS层握手，总计至少需要2-3个RTT。

- TCP层队头阻塞问题依然存在

  TCP协议在收到数据后，这部分数据可能是乱序到达的，但是TCP必须将所有数据收集排序整合后给上层使用，如果其中某个包丢了，就必须等待重传，从而阻塞了整个连接的数据使用。

- 移动互联网领域表现不佳(弱网环境)





##### 基于 QUIC协议 的HTTP 3.0 

通过基于UDP自定义的类似TCP的连接、重试、多路复用、流量控制技术进一步提升性能。



**QUIC 特色机制：**

- 自定义连接机制
- 自定义重传机制
- 无阻塞多路复用
- 自定义流量控制



**QUIC 选择UDP的原因：**

- UDP本身是无连接的、没有建链和拆链成本

  TCP三次握手加上HTTPS中TLS层握手，总计至少需要2-3个RTT。

- UDP的数据包无队头阻塞问题。

  在一条链接上可以有多个流，流与流之间互不影响。当一个流出现丢包影响范围非常小，从而解决队头阻塞问题。

- UDP改造成本小



HTTP 3.0又称HTTP Over QUIC，与HTTP 2.0能力力矩对比：

![img](E:\personal\study\StudySpace\images\f2ea7ee7d8a29615f8b80440eb0a20ac.png)







#### **HTTP** 协议的安全性问题

- **明文（不加密）通信，内容可能被窃听**

  HTTP协议中没有加密机制，但可以用过和SSL（安全套接层）或TLS（安全层传输协议）的组合使用加密HTTP的通信内容。

- **不验证通信方的身份，可能遭遇伪装**

  1）任何人都可以发起请求。即使是无意义的请求也会照单全收。无法阻止海量请求下的Dos攻击。

  2）应使用值得信任的第三方机构颁发的证书，可以判断通信双方的身份和真实意图。

- **无法证明报文完整性，所以有可能已遭篡改**

  HTTP协议无法证明通信的报文完整性。**中间人攻击（Man-in-the-Middle attack ,MITM）**指请求或响应在传输途中，遭到攻击者拦截并篡改内容。

  常用的确定报文完整性的方法是MD5和SHA-1 等散列校验方法，以及用来确定文件的数字签名方法。工作项目中常用接口参数加时间戳按字母序排列并进行MD5算法计算，生成签名。

  

**HTTP劫持常见手段**

在运营商的路由器节点上，设置协议检测，一旦发现是HTTP请求，而且是html类型请求，则拦截处理。 常见有两种：

- 类似DNS劫持返回302让用户浏览器跳转到另外的地址。(钓鱼网站)
- 在服务器返回的HTML数据中**插入js或dom节点**（广告）。









#### HTTPS协议

Https并非是应用层的一种新协议。只是HTTP通信接口部分用SSL和TLS协议代替而已。通常HTTP直接和TCP通信，当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信。

![image-20201110114725652](.\images\image-20201110114725652.png)



##### 对称加密和非对称加密

对称加密效率高，非对称加密解决密钥传输的问题





##### SSL和TLS

TLS（Transport Layer Security）是以SSL为原型开发的协议。当前主流SSL 3.0和TLS1.0。

由于HTTPS需要做服务器、客户端双方加密及解密处理，消耗CPU和内存等硬件资源，HTTPS要比HTTP慢2到100倍。





##### Https协议的总体思路：

![img](.\images\10315ffa19492462cadfbdfb3113987e.jpg)



1. 客户端通过发送Client Hello报文开始SSL通信。报文中包含客户端支持的SSL指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。
2. 服务端以Server Hello报文作为应答。和客户端一样，在报文中包含SSL版本以及加密组件。服务端的加密组件内容是从接收到的客户端加密组件中筛选出来的。
3. 服务端发送Certificate报文。报文中包含公开密钥（Public key）证书。
4. 最后服务器发送Server Hello Done报文通知客户端，最初阶段的SSL握手协商部分结束。
5. SSL第一次握手结束之后，客户端以Client Key Exchange报文作为回应。报文包中包含通信加密中使用的一种被称为Pre-master secret的随机密码串。该串已通过步骤3中服务端传来的公开密钥（Public key）进行加密。
6. 接着客户端继续发送Change Cipher Spec报文。该报文提示服务器，在此报文后的通信会采用Pre-master secret密钥加密。
7. 客户端发送Finished报文。该报文包含连接至今全部报文整体校验值。这次握手协商是否成功，要以服务器是否能够正确解密该报文作为判定标准。
8. 服务器同样发送Change Cipher Spec报文。
9. 服务器同样发送Finished报文。
10. 服务器和客户端的FInished报文交换完毕之后，SSL连接就算建立完成。可以开始应用层协议通信，即HTTP请求和响应。
11. 客户端断开连接时，发送close_notify报文。之后，再发送TCP FIN报文开关闭与TCP的通信。



总结：

双端SSL握手协商，交换随机数，验证证书（通常是CA证书）确认身份，客户端生成随机串Pre-master secret 并使用服务端传来的非对称加密公钥加密。最终客户端和服务器各自通过 两端随机数+Pre-master secret 心照不宣地计算出通信时使用的对称加密密钥。



在以上流程中，应用层发送数据时会附加一种MAC（Message Authentication Code）的报文摘要。能够查知报文是否遭到篡改，从而保护报文的完整性。







##### WebSocket协议

​	WebSocket是一个应用层通信协议，虽然带有Socket字样，但是它并不是基于Socket的封装，甚至风马牛不相及。同为应用层协议，WebSocket协议跟http协议关系要更近一些。

​	所谓“协议”，是通信双方约定的一种合作规范，包括如何建立连接、链接地址格式什么样子、请求头返响应头格式、字段意义等等，两个协议对比来看更直观：

1. http协议请求地址是以" http://"开头，WebSocket协议是以 “ws://”开头。

2. http协议头（略）

   WebSocket协议请求头：	

   ```
   GET /webfin/websocket/ HTTP/1.1
   Host: localhost
   Upgrade: websocket
   Connection: Upgrade
   Sec-WebSocket-Key: xqBt3ImNzJbYqRINxEFlkg==
   Origin: http://localhost:8080
   Sec-WebSocket-Version: 13
   ```

   ​		类似传统HTTP报文，Upgrade：websocket参数值表明这是WebSocket类型请求，Sec-WebSocket-Key是WebSocket客户端发送的一个 base64编码的密文，要求服务端必须返回一个对应加密的Sec-WebSocket-Accept应答，否则客户端会抛出Error during WebSocket handshake错误，并关闭连接

   3. 建立连接与通信

      WebSocket要在开始建立连接时，发送一次http请求

      <img src="https://pic3.zhimg.com/80/v2-9e38e379c1597bd3e45ef5f37c08eaeb_1440w.jpg?source=1940ef5c" alt="img" style="zoom:48%;" />

   4. 

**WebSocket协议存在的意义**

​	**持久连接**

​		WebSocket通过Close关闭连接、Ping/Pong 来探测/回应链路是否畅通。

​	**全双工通信**	

​		http是无状态、只能由客户端发起的单向通信协议。在WebSocket协议出现以前，想要基于http协议实现全双工通信，只能使用轮询，**WebSocket协议本身就是针对于全双工通信设计的，通信双方都可以发起/响应请求。**







#### 流媒体协议









### 数据中心

#### DNS

DNS服务器要满足高可用、高并发、分布式。

![img](.\images\59f79cba26904ff721aabfcdc0c27da6.jpg)

- 根DNS服务器 ： 返回顶级宇DNS服务器地IP地址
- 顶级域DNS服务器：返回权威DNS服务器地IP地址
- 权威DNS服务器：返回相应主机地IP地址



##### DNS解析流程

![img](.\images\ff7e8f824ebd1f7e16ef5d70cd79bdf2.jpg)

1. 客户端发起一个网络请求的时候， 会向本地域名服务器（本地DNS）发起一个DNS请求，请求域名对应的 IP地址。这个本地DNS ，如果通过DHCP配置的话，那么它就是由你的网络服务商（ISP）如电信、移动等自动分配。
2. 本地DNS收到来自客户端的请求。查找缓存的域名与IP对应的表 , 该缓存有TTL时间限制。如果没有，则本地DNS直接去问根域名服务器。
3. 根域名服务器，根据后缀.com、.cn、.net等，将请求下发到顶级域名服务器，进而找到负责该域名的权威域名服务器。
4. 权威域名服务器查询后将地址告诉本地DNS，本地DNS再将IP地址返回给客户端。



DNS除了可以做域名解析，查到具体IP地址外，还有个作用是负载均衡。



##### 负载均衡

- 内部负载均衡

  为减缓应用访问压力，可以部署多个。DNS做 解析的时候，根据配置策略，返回不一样的ip

  

- 全局负载均衡

  为保证应用高可用，往往会部署在多个机房，每个地方有自己的IP。当用户访问某个域名的时候，这个IP可以轮询访问多个数据中心。从而保证，即使某个数据中心挂了，依然不影响用户使用。

  另外，让用户优先访问就近的数据中心，提升访问速度，用户体验就会非常好。



#### HTTPDNS

##### 传统DNS存在的问题

1. **域名缓存问题**

   缓存过期、刷新

   本地缓存使得全局负载均衡失败

2. **域名转发问题**

   本地DNS将解析请求直接发给其他运营商做解析，网络地址发生转换，权威DNS服务器，没法通过地址来判断来自哪个运营商，造成跨运营商访问。

3. **域名更新问题**

   不同运营商独立部署本地DNS服务器，对于域名解析缓存的处理上，实现策略有区别，有的会偷懒，忽略域名解析结果TTL时间限制，导致在权威DNS服务器解析变更的时候，解析结果在全网生效的周期非常漫长。

4. **解析延迟问题**

   递归遍历多个DNS服务器造成的时延

5. **DNS 运营商劫持**

   一般而言，用户上网的DNS服务器都是运营商分配的，所以在这个节点上，运营商可以为所欲为。 例如，访问http://jiankang.qq.com/index.html，正常DNS应该返回腾讯的ip，而DNS劫持后，会返回一个运营商的中间服务器ip。访问该服务器会一致性的返回302，让用户浏览器跳转到预处理好的带广告的网页，在该网页中再通过iframe打开用户原来访问的地址。



##### HttpDNS的工作模式

HttpDNS其实就是自己搭建基于HTTP协议的DNS服务器集群，分布在多个地点和多个运营商。当客户端需要DNS解析的时候，直接通过HTTP协议进行请求这个服务器集群，得到就近的地址。从而绕过运营商的本地DNS服务器（Local DNS）。



##### HTTPDNS的调度设计

客户端收集国家、地区、运营商等信息，HTTPDNS服务端根据这些信息选择最佳服务节点返回。

如果有多个节点，需要客户端使用HttpDNS返回的IP访问业务应用，收集网络请求数据，如错误率、请求时间等网络质量数据，并发到统计后台，进行分析、聚合，在HttpDNS服务端可以根据状况排序，让客户端优先访问当前优质的、时延低的IP地址。



















#### CDN

​	就近配送



#### VPN （Virtual Private Network，虚拟专用网）

​	











### 面试问题

网络协议基础知识梳理这么多，试着回答一下面试常见的问题。



1. ##### 如何保证数据的有效性？

   发送端会把数据切分成多个报文，而报文到达对端的时间和顺序是不确定的，传输层TCP协议的处理方式是给报文分配序列号，接收时根据序列号顺序重组数据。

   类似的，我们可以为任务按照进入工作队列的顺序编号。一个任务完成准备放入结果队列中前，检查序列号是否连续，不连续的话，就暂时放进缓冲队列暂时缓存。缓冲队列需要有序，可以使用链表或最小堆实现。

   

2. ##### 如何保证对方收到了消息？

   我们说TCP提供了可靠传输，但实际上，我们往socket写入的数据，只要对端的内核收到后，就会返回ack，此时socket就认为数据写入成功，不表示应用层已经成功接收并且处理了数据。

   解决办法，我们学TCP添加一个应用层APP ACK。应用层接收消息之后，发送一个APP ACK给对方。

   同样，用超时重试机制，保证APP ACK的可靠性。















### 参考资源

- 极客时间  趣谈网络协议 -- 第一模块、第二模块

  https://time.geekbang.org/column/intro/85

- 腾讯课堂 图灵学院-程序员必会网络知识-重学计算机网络底层原理

- 任玉刚 - 手把手教你写Socket长链接

  https://juejin.cn/post/6844903630047281159






