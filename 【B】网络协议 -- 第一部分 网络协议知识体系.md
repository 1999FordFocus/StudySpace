## 【B】网络协议 -- 第一部分: 网络协议知识体系

> 昔日戏言身后意，今朝都到眼前来。衣裳已施行看尽，针线犹存未忍开。
>
> 尚想旧情怜婢仆，也曾因梦送钱财。诚知此恨人人有，贫贱夫妻百事哀。
>
> -- 《遣悲怀》唐·元稹



### 知识大纲







### 基础知识

**协议三要素 ：**

- 语法 
- 语义
- 顺序



#### 一次网络通信的大致流程

​	要访问一个URL，**应用层**首先要通过地址薄协议DNS或者HTTPDNS，最终得到目标 ip 地址。得到地址后，根据HTTP或者HTTPS协议封装请求包。通过Socket编程将包从应用层传到传输层。**传输层**（添加TCP头）有两种协议TCP、UDP。TCP能够保证包到达目的地，如果不能到达，就会重新发送。接下来包交给**网络层**，**网络层**（添加ip头）协议是 ip 协议。 操作系统启动时会被DHCP协议配置IP地址以及默认的网关的IP地址 192.168.1.1，客户端通过本地局域网广播询问网关mac地址，数据链路层 ARP（地址解析协议）提供ip地址解析成MAC地址服务。ip包从客户端发送MAC层（数据链路层第一子层，添加MAC头），继而通过数据链路层网关的MAC地址，再将包发到网关。网关根据路由表进行跳转，网关间通过路由协议OSPF和BGP沟通。

​	最后一个网关知道这个网络包就是要去这个局域网的，于是拿着目标IP通过ARP协议大喊一声这是谁？ 目标服务器就会给网关回复一个MAC地址。 然后网络包在最后那个网关修改目标的MAC地址，通过这个MAC地址，网络包找到了目标服务器。目标服务器发现MAC地址对上了，取下MAC头来，发送给操作系统网络层，网络层取下IP头，然后交给传输层即TCP层。在这一层里，对于收到的每个包，都会有一个回复，报个平安说包收到了。TCP 头中有目标端口号，可以找到服务端正在监听这个端口号的进程，于是服务端就接收到了HTTP请求包的内容。

#### ![img](.\images\5985d6d430e1b1d3f165bf0f916ed954.jpg)

自己写程序简单实现网络通信模型：

![img](.\images\5c00f6e610f533d17fb4ad7decacc776.jpg)









#### 网络分层的意义

​		只要是在网络上跑的包，都是完整的。可以有下层没上层，绝不可能有上层没下层。对于TCP协议来说，三次握手也好，重试也好，只要想发出去包，就要有IP层和MAC层，不然是发不出去的。

​		Linux 默认的逻辑是，如果这是一个跨网段的调用，它便不会直接将包发送到网络上，而是企图将包发送到网关。





#### IP地址的分配 -- 动态主机配置协议（DHCP）

​	新来的客户机只知道自己mac地址而已，它想要申请一个ip地址，所以使用 0.0.0.0为源ip地址、255.255.255.255为目标ip地址进行广播，这个广播包封装了UDP，UDP封装了BOOTP。

​	![image-20201022141422500](.\images\image-20201022141422500.png)

DHCP server 接收到之后，以客户机mac地址为唯一识别符 ， 通过广播下发DHCP Offer: 

![image-20201022141126092](.\images\image-20201022141126092.png)



客户端从多个Offer中选一个，并发送DHCP request广播数据包表示接收租约。

DHCP Servier 会广播返回给客户机DHCP ACK消息包，确认其加入并将ip地址合法租用信息和配置信息一并放入。







### 网络模型 -- 第二层（数据链路层）到第三层（网络层）



#### ARP 协议

​	在一个局域网里边，知道了ip地址不知道mac地址怎么办呢？ 靠“吼” 。广而告之，发送一个广播包，谁是这个 IP 谁来回答。

![image-20201022143855920](.\images\image-20201022143855920.png)

​	广播报文结构：

![image-20201022144051361](.\images\image-20201022144051361.png)

​	避免每次都用 ARP 请求，机器本地也会进行 ARP 缓存。当然机器会不断地上线下线，IP 也可能会变，所以 ARP 的 MAC 地址缓存过一段时间就会过期。



#### MAC头和IP头的细节

![img](.\images\825e54560a6de08a32e4cab4e0f59f65.jpg)



MAC 头里协议类型用来说明里面是IP 协议。

IP 头里边的版本号，目前主流还是IPV4。TTL是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃。8位协议标识，标识下一层协议是TCP还是UDP。



要访问一个ip地址的时候，先判断是否在同一个网段（用到 CIDR和子网掩码进行“与”操作，判断网络号是否相同）。

**如果是同一网段**，那就直接将源地址和目标地址放入ip头，然后通过ARP获得MAC地址，将源MAC和目的MAC放入MAC头中，发出去就可以了。



​	路由器不等于网关。路由器有5个网口或者网卡，分别连着五个局域网，每个网口的IP地址都和局域网的IP相同网段，它是把守这个局域网的网关。任何一个想要发往其他局域网的包，到达网关后拿下MAC头和IP头，根据自己的路由算法，选择另一个网关，加上IP头和MAC头，然后扔出去。



​	MAC地址是一个局域网内才有效的地址。离开本局域网，就要过网关，MAC头要变，而IP地址如果不改变则称为转发网关，比作“欧洲十国游，不用换护照”；改变IP地址的称为**NAT网关（Network Address Translation）**，比作“玄奘西行，要换通关文牒”



#### 静态路由

​	路由器根据路由表来正确转发流量，一张路由表中包含多条路由规则，其中至少包含三项信息：

- 目的网络：这个包想去哪？
- 出口设备：将包从哪个口扔出去
- 下一条网关：下一个路由器的地址



>  根据 IP 地址静态配置路由规则

```makefile
例如，我们设置 ip route add 10.176.48.0/20 via 10.173.32.1 dev eth0，就说明要去 10.176.48.0/20 这个目标网络，要从 eth0 端口出去，经过 10.173.32.1。
```

​	

#### 动态路由协议

​	动态路由路由器可以根据路由协议算法生成动态路由表，随网络运行状况的变化而变化。路由算法即是求**最短路径**常用的有两种方法，一种是 Bellman-Ford 算法，一种是 Dijkstra 算法。



1. **基于链路状态路由算法的OSPF**

   链路状态路由（link state routing），基于Dijkstra算法实现。思路是：路由器启动的时候向邻居say hello，计算和邻居的距离，然后将自己和邻居之间得链路状态包广播出去，发送到整个网络得每个路由器，因而每个路由器都能在本地构建一个完整得图，然后针对这个图使用Dijkstra算法，找到两点之间最短路径。

   

   相比距离矢量路由更新时发送整个路由表，链路状态路由协议，只广播更新得或改变得网络拓扑，一旦路由器挂了，可使得坏消息迅速收敛。

   

   **OSPF （Open Shortest Path First ， 开放式最短路径优先）**，被称为**内部网关协议（Interior Gateway Protocol ，简称IGP**）。在一个组织内部，最短路径往往最优，有时候OSPF可以发现多个最短路径，可以在多个路径中进行**负载均衡**，这常常称为**等价路由**。

   

   

2. **基于距离矢量路由算法的BGP协议**

   距离矢量路由（Distance vector routing），基于 *Bellman-Ford* 算法实现。思路是：每个路由器都保存一个路由表，每过几秒，每个路由器都将自己所知的到达所有路由器的距离告知邻居，每个路由器也都从邻居那里得到相似的信息。根据新收集的信息，计算和其他路由器的距离。

   ![image-20201028144234349](.\images\image-20201028144234349.png)

   问题1：“坏消息” 同步得慢

   ​	如果目的路由器挂掉了，那么源路由器仍然将尝试各种路径访问，直到试过所有路径。

   

   问题2：每次发送都要发送整个全局路由表。

   

   **外网路由协议（Border Gateway Protocol，简称BGP）**。BGP协议使用的是**路径矢量路由协议(path-vector protocol)** 。它是距离矢量路由协议的升级版。在网络世界，一个个国家称为自治系统AS（Autonomous System），都有边界路由器，通过它和外面得世界建立联系，边界路由器间使用eBGP广播路由，边界路由器再通过运行iBGP，将学习到的路由导入到内部网络。

   

   

   

   

### 网络模型 -- 传输层

> TCP 与 UDP的区别?

1. TCP提供可靠交付。先建立连接，再传输数据，保证无差错、不丢失、不重复并且按序到达。
2. TCP面向字节流，UDP基于数据报，一个个发一个个收。
3. TCP有拥塞控制。





#### UDP 协议

> UDP包头

![image-20201028161716334](.\images\image-20201028161716334.png)

​	当UDP包到达目标机器后，发现MAC地址匹配，于是取下MAC头，将剩下的包传给IP层，将IP头取下，IP头有8位协议位，标识TCP协议还是UDP协议，我们知道了UDP头格式，解析数据，并能交给应用层，无论应用使用TCP还是UDP传数据，都要监听一个端口，正是这个端口用来区分应用程序。



**应用场景**

	1. 需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用。
 	2. 不需要一对一沟通，建立连接，而是可以广播的应用。
 	3. 需要处理速度快、延迟低，可以容忍少数丢包，但是要求即便网络拥塞，也不主动降低速度

​	DHCP、VXLAN、QUIC等





#### TCP协议

TCP主要关注五个问题：

1. 连接维护

2. 顺序问题

3. 丢包问题

4. 流量控制

5. 拥塞控制

   

##### 连接维护--三次握手与四次分手

> TCP头格式

![image-20201028162436982](.\images\image-20201028162436982.png)



**TCP的三次握手**

三次握手的作用是 *双方都能明确自己和对方的收、发能力是正常的*。

主要内容是：1. 双方建立连接 2.沟通初始TCP包的序列号

> **三次握手具体过程与状态机变化：**

![image-20201028164625521](.\images\image-20201028164625521.png)



TCP是全双工通信。通信双方都要完成一次 "发送 - 接收“,方可确定连接建立。一开始，客户端与服务端都处于CLOSED状态。先是服务端主动监听某个端口，处于LISTEN状态。然后客户端主动发起连接SYN，之后处于SYN-SENT状态。服务端收到连接，返回SYN，并且ACK客户端的SYN，之后处于SYN-RCVD状态。客户端收到服务端发送的SYN和ACK之后，发送ACK的ACK，之后处于ESTABLISHED状态，因为它一发一收成功了。服务端收到ACK的ACK之后，处于ESTABLISHED状态，因为它也一发一收了。



每个连接都要有不同的序号，生成序号的机制就是ISN （ initialization sequence number ），序号每4微秒自动加1。避免出现第二次握手丢失的包，绕路又回来了，干扰重试过程，也避免浪费服务端资源。





**TCP四次挥手状态时序图**

![image-20201028192853041](.\images\image-20201028192853041.png)****



1. 客户端发送FIN段，包含seq=p，表示” 不玩了 “ 。之后进入FIN_WAIT_1状态，此时不能再发出数据但是可以接收数据
2. 服务端返回ACK ，并且ack = p+1，表示” 知道了 “ 。之后服务端进入CLOSED_WAIT状态，此时服务端依然可以发
3. 客户端收到后，进入FIN_WAIT_2状态。
4. 服务端主动发送FIN段，表示” 我也不玩了 “。此后不再发送数据。
5. 客户端收到后，返回ACK，表示 ” 确认已关闭 “。进入TIME_WAIT状态，开始等待2MSL (最大报文生存时间，Maximum Segment Lifetime。协议规定2分钟，实际一般30秒）， 此为等待未收到的数据。



- 为什么这样设计？

  对于关闭连接来说，如果两方谁采取直接“跑路 ”式策略。客户端如果只是通知了一次FIN 就“ 跑路 ”的话，服务端不知道如何处理，没发完的数据还要不要了 ? 而如果服务端收到后直接 “ 跑路”  的话，客户端就不知道服务端是怎么一回事， 是有事要处理，还是等一会儿会发送结束。

- 为什么握手是3次，分手是4次？

  客户端发送FIN表示关闭连接不再发数据后，服务端要立即回复 ACK表示 ” 关闭连接的请求收到了”  ，否则由于TCP协议特性，客户端可能认为丢包了，会重新发送。但这时候只是进入了半关闭状态，服务端是“被通知关闭”的一方，它要等待数据发送完，才能发送自己的FIN 告知客户端连接已关闭，不再发数据。所以相比握手，多出来一步。握手的时候，是服务端在LISTEN状态下，万事俱备静静等待连接请求。



##### 顺序问题、丢包问题、流量控制

顺序问题、丢包问题、流量控制都是通过**滑动窗口**来解决的 ，接收方的窗口大小（能接收多少） 网络情况，能发送多快 这两个条件决定了发送方最终发送的速度。



##### 拥塞控制

​	TCP 的拥塞控制主要来避免两种现象，包丢失和超时重传。一旦出现了这些现象就说明，发送速度太快了，要慢一点。

​	**TCP BBR 拥塞算法**











#### 套接字Socket























### 网络模型 -- 应用层

#### HTTP 协议



#### HTTPS协议



#### 流媒体协议









### 数据中心

#### DNS与HTTPDNS

​	



#### CDN

​	就近配送



#### VPN （Virtual Private Network，虚拟专用网）

​	

















### 参考资源







