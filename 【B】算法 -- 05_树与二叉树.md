## 【B】算法 -- 树与二叉树

### 输出倒逼输入

- B树和B+树的应用场景
- 任意一颗二叉树，求最大节点距离
- 给定排序数组，搜索插入位置



### 二叉树

```
/**
 * 定义二叉树数据结构
 */
static class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    public TreeNode(int value) {
        val = value;
    }
}
```

#### 深度优先遍历

##### 递归方式

每个节点最多被访问两次，时间复杂度与节点数n有关，O(n)

```
/**
 * 中序遍历
 */
public static List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> list = new ArrayList<>();
    inorderRecurse(root, list);
    return list;
}

private static void inorderRecurse(TreeNode tree, List<Integer> orderList) {
    if (tree == null) {
        return;
    }
    inorderRecurse(tree.left,orderList);
    orderList.add(tree.val);
    inorderRecurse(tree.right,orderList);

}
/**
 * 前序遍历
 */
public static List<Integer> preorderTraversal(TreeNode root){
    List<Integer> list = new ArrayList<>();
    preorderRecurse(root, list);
    return list;
}

private static void preorderRecurse(TreeNode tree, List<Integer> orderList){
    if (tree == null){
        return;
    }
    orderList.add(tree.val);//根结点先打印，再左右
    preorderRecurse(tree.left,orderList);
    preorderRecurse(tree.right,orderList);
}

/**
 * 后序遍历
 */
public static List<Integer> postorderTraversal(TreeNode root){
    List<Integer> list = new ArrayList<>();
    postorderRecurese(root,list);
    return list;
}

private static void postorderRecurese(TreeNode root , List<Integer> orderList){
    if (root == null){
        return;
    }
    postorderRecurese(root.left,orderList);
    postorderRecurese(root.right,orderList);
    orderList.add(root.val);
}
```

##### 非递归方式













#### 广度优先遍历





### 二分查找法与二叉查找树

#### 二分查找法





#### 【题目】搜索插入位置

思想



代码



资源参考

 https://leetcode-cn.com/problems/search-insert-position/





#### 二叉查找树



### AVL -- 二叉平衡树





### B树与B+树







### 红黑树































