## 【B】算法 -- 01_排序



### 输出倒逼输入

- **快速排序**与优化
- 几种排序的时间复杂度和基本实现





### 算法评价标准

#### 时间复杂度分析

加法法则：

​	多个循环，并列关系，各复杂度相加关系，但只关注复杂度最大时间复杂度



乘法法则：

​	嵌套两层或多层循环或递归，各层时间复杂度相乘



对于数据规模n ：

- ​	被完整循环c*n次 ： O（n^1）


- ​	两层循环，n不在循环内动态修改 ： O（n^2）


- ​	一次递归调用或循环中n被折半 :    O(logn) ，即求递归深度，递归多少次n被递归到底。

  ```
   i=1;
   while (i <= n)  {
     i = i * 2;
   }
  ```

  ```
  
   i=1;
   while (i <= n)  {
     i = i * 3;
   }
  ```

  

​		对数之间是可以互相转换的，log3n 就等于 log32 * log2n，所以 O(log3n) = O(C * log2n)； 统一都计为O（logN）

- ​	多次递归调用，需要画出递归树




对于两个变量决定，且有各自数据规模m，n的算法：

```
int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
```



加法法则要改成O（M+N），乘法法则依旧有效，O（M*N）





#### 空间复杂度分析

空间复杂度：开辟的存储空间与数据规模n之间的增长关系。



对于数据规模n：

​	多开一个辅助的数组 ： O(n)

​	多开一个辅助的二维数组：O(n^2)

​	多开常数空间：O(1)





#### 最好、最坏时间复杂度

来个稍微复杂的例子：

```
// n表示数组array的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
```

最坏的情况，x不存在于数组中，这样就得遍历一遍数组，才知道结果。O(n)

最好的情况，第一个位置就是x，程序结束，O(1)






#### 稳定性

**排序前相等元素，排序后其相对次序不发生改变**。这个性质对于复杂对象排序来讲尤为重要。对于单一元素（比如数字）排序，毫无意义。











### 经典排序算法基本实现



#### 冒泡排序

```java
/**
 * 冒泡排序
 * 思想：
 *  相邻两个元素依次比较并交换位置，这样每一轮都把最大的元素推到最后的位置（竖着看就是最上边的位置，故称为冒泡）
 */
public class BubbleSort implements ISort {

    @Override
    public int[] sort(int[] array) {
        if (array.length == 0) {
            return array;
        }
        //i代表第几轮，一轮确定一个元素的最后位置
        for (int i = 0; i < array.length; i++) {
            for (int j = 0; j < array.length - 1 - i; j++) {
                if (array[j + 1] > array[j]) {
                    int temp = array[j + 1];
                    array[j + 1] = array[j];
                    array[j] = temp;
                }
            }
        }
        return array;
    }
}
```





#### 选择排序

```java
/**
 * 选择排序
 * 思想：也是两轮循环，外循环index表示排到了哪个位置，内循环从该位置向后寻找更小的元素，并记录其下标，最后交换两元素交换位置
 */
public class SelectionSort implements ISort {
    @Override
    public int[] sort(int[] array) {
        int n = array.length;

        for (int i = 0; i < n; i++) {
            int minIndex = i;
            for (int j = i + 1; j < n; j++) {
                if (array[j] < array[minIndex]) {
                    minIndex = j;
                }
            }
            int temp = array[minIndex];
            array[minIndex] = array[i];
            array[i] = temp;
        }
        return array;
    }
}
```







#### 插入排序







#### 希尔排序





#### 归并排序













#### 快速排序





















#### 堆排序







#### 计数排序







#### 桶排序







#### 基数排序



































### 总结：

1s之内排序算法解决问题的数据规模：

|          | 数据规模            |
| -------- | ------------------- |
| O(n^2)   | 10^4 级别的数据规模 |
| O(nlogn) | 10^7 级别的数据规模 |
| O(n)     | 10^8 级别的数据规模 |



**几种排序性能评测总结：**

![排序算法分析.jpeg](.\images\bVbCXi7)

- n 表示 数据规模
- k 表示 “桶”的个数
- In-Place、Out-Place 内排序、外排序







### 资源参考

- 七大经典排序算法总结

  https://segmentfault.com/a/1190000021638663











 

